#!/usr/local/bin/python3
#-*- coding: utf-8 -*-
# Глава 15. Сервер PyMailCGI.
# Вспомогательные модули.
# Шифрование паролей.
# Пример 16.13 (Лутц Т2 стр.651)
"""
# ---------------------------------------------------------------------------- #
PyMailCGI шифрует пароль, когда он пересылается клиенту или от него через
сеть вместе с именем пользователя в скрытых полях форм или в параметрах
запроса URL; использует функции encode/decode в этом модуле для шифрования
пароля - выгрузите на сервер собственную версию этого модуля, чтобы
использовать другой механизм шифрования; PyMailCGI не сохраняет пароли
на сервере и не отображает его при вводе пользователем в форме ввода,
но это не дает 100% защиты - файл этого модуля сам может оказаться уязвим;
использование протокола HTTPS может оказаться более удачным и более простым
решением, но классы реализации веб-сервера в стандартной библиотеке Python
не поддерживают его;
# ---------------------------------------------------------------------------- #
"""

import sys, time

dayofweek = time.localtime(time.time())[6]					# для реализации собственных схем
forceReadablePassword = False

# ---------------------------------------------------------------------------- #
#                          Схемы преобразования строк                          #
# ---------------------------------------------------------------------------- #

if not forceReadablePassword:
# ---------------------------------------------------------------------------- #
	# по умолчанию не делать ничего: вызовы urllib.parse.quote
	# или cgi.escape (html.escape) в commonhtml.py выполняют необходимое
	# экранирование пароля для встраивания его в URL или HTML;
	# модуль cgi автоматически выполнит обратное преобразование;
# ---------------------------------------------------------------------------- #
	def stringify(old): return old
	def unstringify(old): return old

else:
# ---------------------------------------------------------------------------- #
	# преобразование кодированной строки в/из строки цифр,
	# чтобы избежать проблем с некоторыми специальными/непечатаемыми
	# символами, но сохранить возможность чтения результата
	# (хотя и зашифрованного); в некоторых браузерах есть проблемы
	# с преобразованными амперсандами и т.д.;
# ---------------------------------------------------------------------------- #
	separator = '-'

	def stringify(old):
		new = ''
		for char in old:
			ascii = str(ord(char))
			new = new + separator + ascii					# '-ascii-ascii-ascii'
		return new

	def unstringify(old):
		new = ''
		for ascii in old.split(separator)[1:]:
			new = new + chr(int(ascii))
		return new

# ---------------------------------------------------------------------------- #
# схемы шифрования: пробует PyCrypto, затем rotor,
# затем простейший,нестандартный алгоритм
# ---------------------------------------------------------------------------- #

useCrypto = useRotor = True
try:
	import Crypto
except:
	useCrypto = False
	try:
		import rotor
	except:
		useRotor = False

if useCrypto:
# ---------------------------------------------------------------------------- #
# использовать алгоритм AES из стороннего пакета pycrypto (pycryptodome)
# предполагается, что в конце строки пароля отсутствует
# символ '\0': используется для дополнения справа
# измените закрытый ключ здесь, если используете этот метод
# ---------------------------------------------------------------------------- #

	sys.stderr.write('using PyCryptoDome\n')
	from Crypto.Cipher import AES

	mykey = 'pymailcgi3'.ljust(16, '-').encode('utf8')		# ключ должен иметь длину 16, 24, или 32 символа

	def do_encode(pswd):
		over = len(pswd) % 16
		if over:
			pswd += '\0' * (16 - over)						# дополнение: длина должна быть кратна 16
			aesobj = AES.new(mykey, AES.MODE_ECB)
			return aesobj.encrypt(pswd.encode('utf8'))

	def do_decode(pswd):
		aesobj = AES.new(mykey, AES.MODE_ECB)
		pswd = aesobj.decrypt(pswd).decode('utf8')
		return pswd.rstrip('\0')

elif useRotor:
# ---------------------------------------------------------------------------- #
# использовать для шифрования стандартный модуль rotor
# он лучше подходит для шифрования, чем программный код выше
# к сожалению, он больше не доступен в Py 2.4+
# ---------------------------------------------------------------------------- #

	sys.stderr.write('using rotor\n')
	import rotor
	mykey = 'pymailcgi3'

	def do_encode(pswd):
		robj = rotor.newrotor(mykey)						# использовать алгоритм enigma
		return robj.encrypt(pswd)

	def do_decode(pswd):
		robj = rotor.newrotor(mykey)
		return robj.decrypt(pswd)

else:
# ---------------------------------------------------------------------------- #
# в крайнем случае использовать собственную схему, основанную
# на искажении символов некоторым обратимым способом
# предупреждение: слишком простой алгоритм - замените своим
# ---------------------------------------------------------------------------- #

	sys.stderr.write('using simple\n')
	adder = 1

	def do_encode(pswd):
		pswd = 'vs' + pswd + '48'
		res = ''
		for char in pswd:
			res += chr(ord(char) + adder)					# увеличить каждый код ASCII
		return str(res)

	def do_decode(pswd):
		pswd = pswd[2:-2]
		res = ''
		for char in pswd:
			res += chr(ord(char) - adder)
		return res

# ---------------------------------------------------------------------------- #
#                            функции верхнего уровня                           #
# ---------------------------------------------------------------------------- #

def encode(pswd):
	return stringify(do_encode(pswd))						# шифрование плюс преобразование строки

def decode(pswd):
	return do_decode(unstringify(pswd))


if __name__ == "__main__":
	data = encode('spam@123+')
	print(data)
	print(decode(data))

	# raw = do_encode('spam@123+')
	# print(raw)
	# text = stringify(raw)
	# print(text)
	# print(len(raw), len(text))